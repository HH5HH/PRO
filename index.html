<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[PRO]</title>
    <style>
        /* Adobe Spectrum CSS Design Tokens */
        :root {
            /* Spectrum Colors - Light Theme */
            --spectrum-global-color-gray-50: #fafafa;
            --spectrum-global-color-gray-75: #f5f5f5;
            --spectrum-global-color-gray-100: #eaeaea;
            --spectrum-global-color-gray-200: #e1e1e1;
            --spectrum-global-color-gray-300: #cacaca;
            --spectrum-global-color-gray-400: #b3b3b3;
            --spectrum-global-color-gray-500: #8e8e8e;
            --spectrum-global-color-gray-600: #6e6e6e;
            --spectrum-global-color-gray-700: #4a4a4a;
            --spectrum-global-color-gray-800: #2c2c2c;
            --spectrum-global-color-gray-900: #080808;
            
            /* Spectrum Blue (Primary) */
            --spectrum-global-color-blue-300: #5dade2;
            --spectrum-global-color-blue-400: #2680eb;
            --spectrum-global-color-blue-500: #1473e6;
            --spectrum-global-color-blue-600: #0d66d0;
            --spectrum-global-color-blue-700: #095aba;
            
            /* Spectrum Green (Success) */
            --spectrum-global-color-green-300: #4ecdc4;
            --spectrum-global-color-green-400: #2d9d78;
            --spectrum-global-color-green-500: #268e6c;
            --spectrum-global-color-green-600: #12805c;
            
            /* Spectrum Red (Error) */
            --spectrum-global-color-red-300: #f1948a;
            --spectrum-global-color-red-400: #e34850;
            --spectrum-global-color-red-500: #d7373f;
            --spectrum-global-color-red-600: #c6363f;
            
            /* Spectrum Orange (Warning) */
            --spectrum-global-color-orange-300: #f5b041;
            --spectrum-global-color-orange-400: #e68619;
            --spectrum-global-color-orange-500: #da7b11;
            
            /* Spectrum Spacing */
            --spectrum-global-dimension-size-25: 2px;
            --spectrum-global-dimension-size-50: 4px;
            --spectrum-global-dimension-size-75: 6px;
            --spectrum-global-dimension-size-100: 8px;
            --spectrum-global-dimension-size-150: 12px;
            --spectrum-global-dimension-size-200: 16px;
            --spectrum-global-dimension-size-250: 20px;
            --spectrum-global-dimension-size-300: 24px;
            --spectrum-global-dimension-size-400: 32px;
            --spectrum-global-dimension-size-500: 40px;
            --spectrum-global-dimension-size-600: 48px;
            --spectrum-global-dimension-size-700: 56px;
            --spectrum-global-dimension-size-800: 64px;
            
            /* Spectrum Typography */
            --spectrum-alias-body-text-font-family: adobe-clean, 'Source Sans Pro', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --spectrum-alias-code-text-font-family: 'Source Code Pro', Monaco, 'Courier New', monospace;
            --spectrum-alias-font-size-default: 14px;
            --spectrum-alias-line-height-default: 1.5;
            
            /* Spectrum Border Radius */
            --spectrum-alias-border-radius-small: 4px;
            --spectrum-alias-border-radius-regular: 6px;
            --spectrum-alias-border-radius-large: 8px;
            
            /* Spectrum Shadows */
            --spectrum-alias-shadow-color: rgba(0, 0, 0, 0.15);
            --spectrum-alias-shadow-size-small: 0 1px 2px;
            --spectrum-alias-shadow-size-medium: 0 2px 4px;
            --spectrum-alias-shadow-size-large: 0 4px 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--spectrum-alias-body-text-font-family);
            font-size: var(--spectrum-alias-font-size-default);
            line-height: var(--spectrum-alias-line-height-default);
            background: var(--spectrum-global-color-gray-75);
            color: var(--spectrum-global-color-gray-800);
            min-height: 100vh;
            padding: var(--spectrum-global-dimension-size-250);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--spectrum-global-color-gray-50);
            border-radius: var(--spectrum-alias-border-radius-large);
            box-shadow: var(--spectrum-alias-shadow-size-medium) var(--spectrum-alias-shadow-color);
            overflow: hidden;
        }

        .header {
            background: var(--spectrum-global-color-gray-900);
            color: var(--spectrum-global-color-gray-50);
            padding: var(--spectrum-global-dimension-size-200) var(--spectrum-global-dimension-size-400);
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: var(--spectrum-global-dimension-size-200);
            border-bottom: 1px solid var(--spectrum-global-color-gray-700);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: var(--spectrum-global-dimension-size-200);
            flex: 1;
            justify-content: flex-end;
        }

        .header-status {
            font-size: 12px;
            padding: var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150);
            border-radius: var(--spectrum-alias-border-radius-regular);
            min-height: 32px;
            display: flex;
            align-items: center;
            flex: 1;
            max-width: none;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: visible;
            line-height: 1.4;
        }

        .content {
            padding: var(--spectrum-global-dimension-size-400);
            display: none; /* Hidden by default until authenticated */
        }

        .content.authenticated {
            display: block; /* Show only when authenticated */
        }

        .picker-section {
            margin-bottom: var(--spectrum-global-dimension-size-400);
        }

        .picker-row {
            display: flex;
            flex-direction: row;
            gap: var(--spectrum-global-dimension-size-300);
            margin-top: var(--spectrum-global-dimension-size-250);
        }

        .picker-row .picker-col {
            flex: 1 1 0;
            min-width: 0;
        }

        .picker-row .picker-col label {
            margin-top: 0;
        }

        .picker-section label {
            display: block;
            font-size: 16px;
            font-weight: 700;
            margin-bottom: var(--spectrum-global-dimension-size-150);
            color: var(--spectrum-global-color-gray-800);
        }

        .programmer-select {
            width: 100%;
            padding: var(--spectrum-global-dimension-size-150) var(--spectrum-global-dimension-size-200);
            font-size: var(--spectrum-alias-font-size-default);
            font-family: var(--spectrum-alias-body-text-font-family);
            border: 1px solid var(--spectrum-global-color-gray-300);
            border-radius: var(--spectrum-alias-border-radius-regular);
            background: var(--spectrum-global-color-gray-50);
            color: var(--spectrum-global-color-gray-800);
            cursor: pointer;
            transition: border-color 130ms ease-out, box-shadow 130ms ease-out;
        }

        .programmer-select:hover:not(:disabled) {
            border-color: var(--spectrum-global-color-gray-400);
        }

        .programmer-select:focus {
            outline: none;
            border-color: var(--spectrum-global-color-blue-500);
            box-shadow: 0 0 0 1px var(--spectrum-global-color-blue-500);
        }

        .programmer-select:disabled {
            background: var(--spectrum-global-color-gray-100);
            color: var(--spectrum-global-color-gray-500);
            cursor: not-allowed;
        }

        .metadata-section {
            margin-top: var(--spectrum-global-dimension-size-400);
        }

        .metadata-section h2 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spectrum-global-dimension-size-250);
            color: var(--spectrum-global-color-gray-800);
            border-bottom: 2px solid var(--spectrum-global-color-blue-500);
            padding-bottom: var(--spectrum-global-dimension-size-100);
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: color 130ms ease-out;
        }

        .metadata-section h2:hover {
            color: var(--spectrum-global-color-blue-600);
        }

        .metadata-section h2 .collapse-icon {
            font-size: 16px;
            transition: transform 200ms ease-out;
            margin-left: var(--spectrum-global-dimension-size-100);
        }

        .metadata-section h2.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .metadata-container {
            background: var(--spectrum-global-color-gray-75);
            border-radius: var(--spectrum-alias-border-radius-large);
            padding: var(--spectrum-global-dimension-size-250);
            max-height: 70vh;
            overflow-y: auto;
            transition: max-height 300ms ease-out, opacity 200ms ease-out, padding 300ms ease-out;
        }

        .metadata-container.collapsed {
            max-height: 0 !important;
            opacity: 0;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0;
        }

        .metadata-item {
            margin-bottom: var(--spectrum-global-dimension-size-250);
            padding: var(--spectrum-global-dimension-size-200);
            background: var(--spectrum-global-color-gray-50);
            border-radius: var(--spectrum-alias-border-radius-regular);
            border-left: 3px solid var(--spectrum-global-color-blue-500);
            box-shadow: var(--spectrum-alias-shadow-size-small) var(--spectrum-alias-shadow-color);
        }

        .metadata-key {
            font-weight: 700;
            color: var(--spectrum-global-color-blue-600);
            font-size: 15px;
            margin-bottom: var(--spectrum-global-dimension-size-100);
            text-transform: capitalize;
        }

        .metadata-value {
            color: var(--spectrum-global-color-gray-700);
            word-break: break-word;
            font-family: var(--spectrum-alias-code-text-font-family);
            font-size: 13px;
            line-height: 1.6;
        }

        .metadata-value pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        .empty-state {
            text-align: center;
            padding: var(--spectrum-global-dimension-size-700) var(--spectrum-global-dimension-size-250);
            color: var(--spectrum-global-color-gray-500);
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: var(--spectrum-global-dimension-size-250);
            opacity: 0.5;
        }

        .loading {
            text-align: center;
            padding: var(--spectrum-global-dimension-size-500);
            color: var(--spectrum-global-color-blue-600);
            font-size: 16px;
        }

        .array-item, .object-item {
            margin-left: var(--spectrum-global-dimension-size-250);
            margin-top: var(--spectrum-global-dimension-size-50);
            padding-left: var(--spectrum-global-dimension-size-200);
            border-left: 1px solid var(--spectrum-global-color-gray-200);
        }

        .null-value {
            color: var(--spectrum-global-color-gray-500);
            font-style: italic;
        }

        .string-value {
            color: var(--spectrum-global-color-green-600);
        }

        .number-value {
            color: var(--spectrum-global-color-blue-600);
        }

        .boolean-value {
            color: var(--spectrum-global-color-red-500);
        }

        /* Spectrum Scrollbar styling */
        .metadata-container::-webkit-scrollbar {
            width: var(--spectrum-global-dimension-size-100);
        }

        .metadata-container::-webkit-scrollbar-track {
            background: var(--spectrum-global-color-gray-100);
            border-radius: var(--spectrum-alias-border-radius-regular);
        }

        .metadata-container::-webkit-scrollbar-thumb {
            background: var(--spectrum-global-color-gray-400);
            border-radius: var(--spectrum-alias-border-radius-regular);
        }

        .metadata-container::-webkit-scrollbar-thumb:hover {
            background: var(--spectrum-global-color-gray-500);
        }

        .file-status-success {
            background: var(--spectrum-global-color-green-400);
            color: var(--spectrum-global-color-gray-50);
            border: 1px solid var(--spectrum-global-color-green-500);
        }

        .file-status-error {
            background: var(--spectrum-global-color-red-400);
            color: var(--spectrum-global-color-gray-50);
            border: 1px solid var(--spectrum-global-color-red-500);
        }

        .application-link {
            color: var(--spectrum-global-color-blue-600);
            text-decoration: none;
            font-weight: 600;
            border-bottom: 1px solid var(--spectrum-global-color-blue-500);
            transition: all 130ms ease-out;
            display: inline-block;
        }

        .application-link:hover {
            color: var(--spectrum-global-color-blue-700);
            border-bottom-color: var(--spectrum-global-color-blue-700);
            background: rgba(38, 128, 235, 0.1);
            padding: 2px 4px;
            border-radius: var(--spectrum-alias-border-radius-small);
        }

        .application-link:visited {
            color: var(--spectrum-global-color-blue-700);
        }

        #authBtn {
            padding: var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-200);
            font-size: 12px;
            background: var(--spectrum-global-color-blue-600);
            color: var(--spectrum-global-color-gray-50);
            border: 1px solid var(--spectrum-global-color-blue-500);
            border-radius: var(--spectrum-alias-border-radius-regular);
            cursor: pointer;
            transition: all 130ms ease-out;
            font-weight: 600;
            white-space: nowrap;
        }

        #authBtn:hover {
            background: var(--spectrum-global-color-blue-500);
            border-color: var(--spectrum-global-color-blue-400);
        }

        #authBtn:active {
            background: var(--spectrum-global-color-blue-700);
            transform: scale(0.98);
        }

        #cancelLoginBtn:hover {
            background: var(--spectrum-global-color-red-600);
        }

        #cancelLoginBtn:active {
            background: var(--spectrum-global-color-red-600);
            transform: scale(0.98);
        }

        #closeModalBtn:hover {
            color: var(--spectrum-global-color-gray-700);
        }


        #loginModal {
            display: none;
        }

        #loginModal.show {
            display: flex !important;
        }

        .premium-service-section {
            margin-top: var(--spectrum-global-dimension-size-300);
            border: 2px solid var(--spectrum-global-color-gray-200);
            border-radius: var(--spectrum-alias-border-radius-large);
            background: linear-gradient(180deg, #ffffff 0%, #f6f8fa 100%);
            padding: var(--spectrum-global-dimension-size-250);
        }

        .premium-service-section h2 {
            margin-bottom: var(--spectrum-global-dimension-size-150);
            border-bottom: 2px solid var(--spectrum-global-color-blue-500);
            font-size: 22px;
        }

        .service-degradation h2 {
            border-bottom-color: #d7373f;
        }

        .service-esm h2 {
            border-bottom-color: #0d66d0;
        }

        .service-rest-v2 h2 {
            border-bottom-color: #268e6c;
        }

        .service-summary {
            margin-bottom: var(--spectrum-global-dimension-size-200);
            color: var(--spectrum-global-color-gray-700);
            font-size: 13px;
            line-height: 1.5;
        }

        .service-actions {
            margin-bottom: var(--spectrum-global-dimension-size-200);
            display: flex;
            justify-content: flex-end;
        }

        .service-refresh-btn {
            padding: var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-200);
            border: 1px solid var(--spectrum-global-color-blue-400);
            border-radius: var(--spectrum-alias-border-radius-regular);
            background: var(--spectrum-global-color-blue-500);
            color: var(--spectrum-global-color-gray-50);
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
        }

        .service-refresh-btn:hover {
            background: var(--spectrum-global-color-blue-600);
        }

        .service-refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .status-pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            margin-right: 8px;
            margin-bottom: 4px;
        }

        .status-applied {
            background: rgba(45, 157, 120, 0.2);
            color: #12805c;
            border: 1px solid rgba(45, 157, 120, 0.4);
        }

        .status-pending {
            background: rgba(230, 134, 25, 0.2);
            color: #da7b11;
            border: 1px solid rgba(230, 134, 25, 0.4);
        }

        .status-none {
            background: rgba(110, 110, 110, 0.16);
            color: #4a4a4a;
            border: 1px solid rgba(110, 110, 110, 0.25);
        }

        .esm-table-wrapper {
            max-height: 18em;
            overflow: auto;
            border: 1px solid #d7d7d7;
            border-radius: var(--spectrum-alias-border-radius-regular);
            background: #ffffff;
        }

        .esm-table {
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
            font-size: 13px;
        }

        .esm-table th,
        .esm-table td {
            border: 1px solid #ececec;
            padding: 6px 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: left;
        }

        .esm-table thead th {
            position: sticky;
            top: 0;
            background: #ecefed;
            z-index: 1;
            font-weight: 700;
        }

        .esm-table tfoot td {
            position: sticky;
            bottom: 0;
            background: #ecefed;
            z-index: 2;
            border-top: 1px solid #d7d7d7;
        }

        .esm-table tbody tr:nth-child(odd) {
            background: #f9faf9;
        }

        .esm-table tbody tr:nth-child(even) {
            background: #f1f3f1;
        }

        .esm-table th.active-sort {
            color: var(--spectrum-global-color-blue-600);
        }

        .esm-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 12px;
            color: #4a5568;
            width: 100%;
        }

        .esm-footer a {
            color: var(--spectrum-global-color-blue-600);
            text-decoration: underline;
            cursor: pointer;
            font-weight: 700;
        }

        .esm-last-modified {
            color: var(--spectrum-global-color-gray-600);
        }

        .service-error {
            color: var(--spectrum-global-color-red-500);
            font-weight: 600;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-right">
                <div id="authMessage" class="header-status"></div>
                <button id="authBtn">LOGIN HERE</button>
            </div>
        </div>
        <div class="content">
            
            <!-- Modal overlay for login popup -->
            <div id="loginModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 10000; justify-content: center; align-items: center;">
                <div style="background: var(--spectrum-global-color-gray-50); border-radius: var(--spectrum-alias-border-radius-large); padding: var(--spectrum-global-dimension-size-400); max-width: 500px; width: 90%; box-shadow: var(--spectrum-alias-shadow-size-large) var(--spectrum-alias-shadow-color); position: relative;">
                    <button id="closeModalBtn" style="position: absolute; top: var(--spectrum-global-dimension-size-200); right: var(--spectrum-global-dimension-size-200); background: none; border: none; font-size: 24px; cursor: pointer; color: var(--spectrum-global-color-gray-500); transition: color 130ms ease-out;">&times;</button>
                    <h2 style="margin-bottom: var(--spectrum-global-dimension-size-200); color: var(--spectrum-global-color-gray-800); font-size: 20px; font-weight: 700;">Adobe Experience Cloud Login</h2>
                    <p style="margin-bottom: var(--spectrum-global-dimension-size-250); color: var(--spectrum-global-color-gray-600); font-size: var(--spectrum-alias-font-size-default);">Please complete the login in the popup window. This window will close automatically after successful authentication.</p>
                    <div id="modalStatus" style="padding: var(--spectrum-global-dimension-size-100); border-radius: var(--spectrum-alias-border-radius-regular); background: var(--spectrum-global-color-blue-400); color: var(--spectrum-global-color-gray-50); margin-bottom: var(--spectrum-global-dimension-size-200);">
                        Opening login window...
                    </div>
                    <button id="cancelLoginBtn" style="padding: var(--spectrum-global-dimension-size-100) var(--spectrum-global-dimension-size-250); background: var(--spectrum-global-color-red-500); color: var(--spectrum-global-color-gray-50); border: none; border-radius: var(--spectrum-alias-border-radius-regular); cursor: pointer; width: 100%; font-weight: 700; transition: background-color 130ms ease-out;">
                        Cancel Login
                    </button>
                </div>
            </div>
            <div class="picker-section">
                <div class="picker-row">
                    <div class="picker-col">
                        <label for="programmerSelect">Select a Programmer (Media-Company):</label>
                        <select id="programmerSelect" class="programmer-select" disabled>
                            <option value="">-- Please login first --</option>
                        </select>
                    </div>
                    <div class="picker-col">
                        <label for="contentProviderSelect">Content Provider (RequestorId):</label>
                        <select id="contentProviderSelect" class="programmer-select" disabled>
                            <option value="">-- Select a Programmer first --</option>
                        </select>
                    </div>
                </div>
                <label for="mvpdSelect" style="display: block; margin-top: var(--spectrum-global-dimension-size-250);">MVPDs from config:</label>
                <select id="mvpdSelect" class="programmer-select" disabled>
                    <option value="">-- Select a Content Provider first --</option>
                </select>
            </div>
            <div class="metadata-section">
                <h2 id="metadataHeader" style="cursor: pointer;">
                    <span>Metadata</span>
                    <span class="collapse-icon">‚ñº</span>
                </h2>
                <div id="metadataContainer" class="metadata-container">
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <p>Select a programmer from the dropdown above to view their metadata</p>
                    </div>
                </div>
            </div>
            <div id="premiumServicesContainer"></div>
        </div>
    </div>

    <script>
        let programmersData = null;
        let isAuthenticated = false;
        let statusMessageTimeout = null; // Track timeout for auto-clearing messages
        const ADOBE_IMS_BASE = 'https://ims-na1.adobelogin.com';
        const ADOBE_EXPERIENCE_BASE = 'https://experience.adobe.com';
        const ADOBE_CONSOLE_BASE = 'https://console.auth.adobe.com'; // API endpoints may still use this
        const ADOBE_TVE_DASHBOARD = 'https://experience.adobe.com/#/@adobepass/pass/authentication/release-production';
        const ADOBE_CLIENT_ID = 'AdobePass1';
        const ADOBE_SCOPES = 'openid,AdobeID,read_organizations,additional_info.projectedProductContext,write_pc';
        const ADOBE_MGMT_BASE = 'https://mgmt.auth.adobe.com';
        const ADOBE_SP_BASE = 'https://sp.auth.adobe.com';
        const DCR_CACHE_PREFIX = 'pro.dcr.cache.v1';
        const PREMIUM_SERVICE_ORDER = ['degradation', 'esm', 'restV2'];
        const PREMIUM_SERVICE_SCOPE_BY_KEY = {
            degradation: 'decisions:owner',
            esm: 'analytics:client',
            restV2: 'api:client:v2'
        };
        const PREMIUM_SERVICE_TITLE_BY_KEY = {
            degradation: 'Degradation',
            esm: 'ESM',
            restV2: 'REST V2'
        };
        const ESM_INLINE_RESULT_LIMIT = 50;
        const ESM_SOURCE_UTC_OFFSET_MINUTES = -8 * 60;
        const CLIENT_TIMEZONE = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
        let activeMetadataRequestToken = 0;
        const dcrEnsureTokenPromiseByKey = new Map();

        // Check authentication status
        async function checkAuthentication() {
            try {
                // Skip the test endpoint (it returns 406) and go straight to verifying with programmers API
                // This is the most reliable way to check authentication
                return await verifyAuthWithProgrammersApi();
            } catch (error) {
                console.log('Auth check error:', error);
                updateAuthStatus(false, 'Authentication status unknown');
                return false;
            }
        }

        // Verify auth by trying to fetch programmers from API
        async function verifyAuthWithProgrammersApi() {
            try {
                // Use the correct endpoint from CURL: /rest/api/entity/Programmer
                // Try with and without configurationVersion parameter
                const possibleEndpoints = [
                    `${ADOBE_CONSOLE_BASE}/rest/api/entity/Programmer`,
                    `${ADOBE_CONSOLE_BASE}/rest/api/entity/Programmer?configurationVersion=3522`,
                    `${ADOBE_CONSOLE_BASE}/rest/api/programmers`,
                    `${ADOBE_CONSOLE_BASE}/rest/api/v1/programmers`
                ];

                for (const apiUrl of possibleEndpoints) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'GET',
                            credentials: 'include',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json, text/plain, */*',
                                'Origin': 'https://cdn.experience.adobe.net',
                                'Referer': 'https://cdn.experience.adobe.net/'
                            }
                        });

                        if (response.ok) {
                            updateAuthStatus(true, 'Authenticated');
                            window.programmersApiEndpoint = apiUrl; // Store working endpoint
                            return true;
                        } else if (response.status === 401 || response.status === 403) {
                            const errorData = await response.json().catch(() => ({}));
                            if (errorData.error === 'unauthorized' || errorData.error === 'access_denied') {
                                updateAuthStatus(false, 'Not authenticated');
                                return false;
                            }
                        }
                    } catch (e) {
                        // Try next endpoint
                        continue;
                    }
                }

                // If we get here, endpoints don't exist or returned other errors
                // But user might still be authenticated (cookies might work for downloads)
                // Since we couldn't verify with any endpoint, assume not authenticated for safety
                updateAuthStatus(false, 'Cannot verify authentication - please login');
                return false;
            } catch (error) {
                updateAuthStatus(false, 'Cannot verify authentication');
                return false;
            }
        }

        // Clear status message
        function clearStatusMessage() {
            const authMessage = document.getElementById('authMessage');
            authMessage.textContent = '';
            authMessage.innerHTML = '';
            authMessage.style.background = '';
            authMessage.style.color = '';
            authMessage.style.border = '';
            authMessage.style.borderLeft = '';
            authMessage.style.padding = '';
            authMessage.style.fontWeight = '';
        }

        // Unified status message handler with auto-expiration
        function updateStatusMessage(message, type = 'info', autoExpire = true) {
            const authMessage = document.getElementById('authMessage');
            
            // Clear any existing timeout
            if (statusMessageTimeout) {
                clearTimeout(statusMessageTimeout);
                statusMessageTimeout = null;
            }
            
            // Set message content (supports HTML)
            if (typeof message === 'string' && (message.includes('<') || message.includes('\n'))) {
                // If message contains HTML tags or newlines, use innerHTML
                if (message.includes('\n') && !message.includes('<')) {
                    authMessage.innerHTML = message.replace(/\n/g, '<br>');
                } else {
                    authMessage.innerHTML = message;
                }
            } else {
                authMessage.textContent = message;
            }
            
            // Reset styles
            authMessage.style.background = '';
            authMessage.style.color = '';
            authMessage.style.border = '';
            authMessage.style.borderLeft = '';
            authMessage.style.padding = '';
            authMessage.style.fontWeight = '';
            
            // Apply styles based on type (dark theme optimized)
            switch(type) {
                case 'loading':
                    authMessage.style.background = 'rgba(55, 142, 240, 0.2)';
                    authMessage.style.color = 'var(--spectrum-global-color-blue-300)';
                    authMessage.style.border = '1px solid rgba(55, 142, 240, 0.4)';
                    authMessage.style.padding = 'var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150)';
                    break;
                case 'success':
                    authMessage.style.background = 'rgba(45, 157, 120, 0.2)';
                    authMessage.style.color = 'var(--spectrum-global-color-green-300)';
                    authMessage.style.border = '1px solid rgba(45, 157, 120, 0.4)';
                    authMessage.style.padding = 'var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150)';
                    break;
                case 'error':
                    authMessage.style.background = 'rgba(227, 72, 80, 0.2)';
                    authMessage.style.color = 'var(--spectrum-global-color-red-300)';
                    authMessage.style.border = '1px solid rgba(227, 72, 80, 0.4)';
                    authMessage.style.padding = 'var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150)';
                    // Errors are fatal - don't auto-expire
                    autoExpire = false;
                    break;
                case 'warning':
                    authMessage.style.background = 'rgba(230, 134, 25, 0.2)';
                    authMessage.style.color = 'var(--spectrum-global-color-orange-300)';
                    authMessage.style.border = '1px solid rgba(230, 134, 25, 0.4)';
                    authMessage.style.padding = 'var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150)';
                    authMessage.style.fontWeight = '600';
                    break;
                case 'info':
                default:
                    authMessage.style.background = 'rgba(255, 255, 255, 0.05)';
                    authMessage.style.color = 'var(--spectrum-global-color-gray-300)';
                    authMessage.style.border = '1px solid rgba(255, 255, 255, 0.1)';
                    authMessage.style.padding = 'var(--spectrum-global-dimension-size-75) var(--spectrum-global-dimension-size-150)';
                    break;
            }
            
            // Auto-expire non-fatal messages after 5 seconds
            if (autoExpire && message) {
                statusMessageTimeout = setTimeout(() => {
                    clearStatusMessage();
                    statusMessageTimeout = null;
                }, 5000);
            }
        }

        // Update authentication status UI
        function updateAuthStatus(authenticated, message) {
            isAuthenticated = authenticated;
            const authBtn = document.getElementById('authBtn');
            const programmerSelect = document.getElementById('programmerSelect');
            const contentArea = document.querySelector('.content');

            if (authenticated) {
                // Show the working area
                contentArea.classList.add('authenticated');
                clearPremiumServicesContainer();
                
                authBtn.textContent = 'üîÑ Refresh Session';
                updateStatusMessage('Loading programmer data from API...', 'loading');
                
                // Automatically load programmers from API
                loadProgrammersFromAPI();
            } else {
                // Hide the working area - only show header console
                contentArea.classList.remove('authenticated');
                clearPremiumServicesContainer();
                
                authBtn.textContent = 'LOGIN HERE';
                updateStatusMessage('‚ö†Ô∏è Ahoy there buckaroo, this tool requires authentication. Please login using the button, and close the popup once you\'re done', 'warning');
                programmerSelect.disabled = true;
                programmerSelect.innerHTML = '<option value="">-- Please login first --</option>';
            }
        }

        let loginPopup = null;
        let loginCheckInterval = null;

        // Initiate Adobe login via popup
        function initiateAdobeLogin() {
            // Show modal
            const modal = document.getElementById('loginModal');
            modal.classList.add('show');
            
            const modalStatus = document.getElementById('modalStatus');
            modalStatus.textContent = 'Opening login window...';
            modalStatus.style.background = '#e7f3ff';
            modalStatus.style.color = '#0066cc';

            // Open TVE Dashboard in popup
            const popupWidth = 800;
            const popupHeight = 600;
            const left = (window.screen.width - popupWidth) / 2;
            const top = (window.screen.height - popupHeight) / 2;
            
            loginPopup = window.open(
                ADOBE_TVE_DASHBOARD,
                'AdobeLogin',
                `width=${popupWidth},height=${popupHeight},left=${left},top=${top},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`
            );

            if (!loginPopup) {
                modalStatus.textContent = 'Popup blocked! Please allow popups and try again.';
                modalStatus.style.background = '#f8d7da';
                modalStatus.style.color = '#721c24';
                return;
            }

            // Monitor popup for closure or successful login
            loginCheckInterval = setInterval(() => {
                if (loginPopup.closed) {
                    clearInterval(loginCheckInterval);
                    modalStatus.textContent = 'Login window closed. Checking authentication...';
                    modalStatus.style.background = '#fff3cd';
                    modalStatus.style.color = '#856404';
                    
                    // Wait a moment for cookies to be set, then check auth
                    setTimeout(async () => {
                        const authenticated = await checkAuthentication();
                        if (authenticated) {
                            modalStatus.textContent = '‚úì Login successful! Loading data...';
                            modalStatus.style.background = '#d4edda';
                            modalStatus.style.color = '#155724';
                            setTimeout(() => {
                                modal.classList.remove('show');
                                // Data will be loaded automatically by updateAuthStatus
                            }, 1500);
                        } else {
                            modalStatus.textContent = 'Login may not have completed. Please try again.';
                            modalStatus.style.background = '#f8d7da';
                            modalStatus.style.color = '#721c24';
                        }
                    }, 1000);
                } else {
                    // Check if popup has navigated to a success page
                    try {
                        const popupUrl = loginPopup.location.href;
                        if (popupUrl && (popupUrl.includes('experience.adobe.com') || popupUrl.includes('console.auth.adobe.com'))) {
                            // Popup is on Adobe domain, might be logged in
                            // We'll wait for popup to close to check
                        }
                    } catch (e) {
                        // Cross-origin, can't access - this is normal
                    }
                }
            }, 500);
        }

        // Close modal handlers
        document.getElementById('closeModalBtn').addEventListener('click', function() {
            if (loginPopup && !loginPopup.closed) {
                loginPopup.close();
            }
            if (loginCheckInterval) {
                clearInterval(loginCheckInterval);
            }
            document.getElementById('loginModal').classList.remove('show');
        });

        document.getElementById('cancelLoginBtn').addEventListener('click', function() {
            if (loginPopup && !loginPopup.closed) {
                loginPopup.close();
            }
            if (loginCheckInterval) {
                clearInterval(loginCheckInterval);
            }
            document.getElementById('loginModal').classList.remove('show');
        });

        // Generate request ID for API calls
        function generateRequestId() {
            const timestamp = Date.now();
            const random = Math.floor(Math.random() * 1000000);
            return `${timestamp}-${random}`;
        }

        // Load programmers from API using the correct endpoint from CURL
        async function loadProgrammersFromAPI() {
            const select = document.getElementById('programmerSelect');
            
            updateStatusMessage('Loading programmers from API...', 'loading');
            select.disabled = true;
            select.innerHTML = '<option value="">Loading...</option>';
            
            try {
                // Use the correct endpoint from CURL: /rest/api/entity/Programmer
                // Try with and without configurationVersion, and try stored endpoint first
                const endpoints = window.programmersApiEndpoint 
                    ? [window.programmersApiEndpoint]
                    : [
                        `${ADOBE_CONSOLE_BASE}/rest/api/entity/Programmer?configurationVersion=3522`,
                        `${ADOBE_CONSOLE_BASE}/rest/api/entity/Programmer`,
                        `${ADOBE_CONSOLE_BASE}/rest/api/programmers`,
                        `${ADOBE_CONSOLE_BASE}/rest/api/v1/programmers`
                    ];

                let lastError = null;
                for (const apiUrl of endpoints) {
                    try {
                        // Build headers matching the CURL request
                        const headers = {
                            'Accept': 'application/json, text/plain, */*',
                            'Origin': 'https://cdn.experience.adobe.net',
                            'Referer': 'https://cdn.experience.adobe.net/',
                            'ap-request-id': generateRequestId()
                        };

                        // Try to get CSRF token from cookies if available
                        // Note: We can't directly read cookies due to security, but browser will send them
                        const response = await fetch(apiUrl, {
                            method: 'GET',
                            credentials: 'include', // This sends cookies automatically
                            mode: 'cors',
                            headers: headers
                        });

                        if (response.ok) {
                            const data = await response.json();
                            
                            // Handle different response formats
                            if (Array.isArray(data)) {
                                // If response is array, wrap it in entities format
                                programmersData = {
                                    count: data.length,
                                    entities: data.map(item => ({
                                        key: item.key || `Programmer:${item.entityData?.id || 'unknown'}`,
                                        version: item.version || 1,
                                        entityData: item.entityData || item
                                    }))
                                };
                            } else if (data.entities) {
                                // Already in expected format
                                programmersData = data;
                            } else {
                                // Single entity or other format
                                programmersData = {
                                    count: 1,
                                    entities: [{
                                        key: data.key || `Programmer:${data.entityData?.id || 'unknown'}`,
                                        version: data.version || 1,
                                        entityData: data.entityData || data
                                    }]
                                };
                            }
                            
                            const count = programmersData.count || programmersData.entities?.length || 0;
                            updateStatusMessage(`‚úì Loaded ${count} programmers from API. Select a programmer to view details.`, 'success');
                            select.disabled = false;
                            populateSelect();
                            window.programmersApiEndpoint = apiUrl; // Store working endpoint
                            return;
                        } else if (response.status === 401 || response.status === 403) {
                            const errorData = await response.json().catch(() => ({}));
                            if (errorData.error === 'unauthorized' || errorData.error === 'access_denied') {
                                throw new Error('Authentication required. Please login first.');
                            }
                            throw new Error(`Access denied: ${response.status} ${response.statusText}`);
                        } else {
                            lastError = new Error(`API error: ${response.status} ${response.statusText}`);
                            continue; // Try next endpoint
                        }
                    } catch (error) {
                        if (error.message.includes('Authentication') || error.message.includes('Access denied')) {
                            throw error; // Don't try other endpoints for auth errors
                        }
                        lastError = error;
                        continue;
                    }
                }

                // If we get here, all endpoints failed
                throw lastError || new Error('Unable to find valid API endpoint. Please use file upload instead.');
            } catch (error) {
                console.error('Error loading from API:', error);
                updateStatusMessage(`‚úó Error: ${error.message}`, 'error');
                select.disabled = true;
                select.innerHTML = '<option value="">Error loading data</option>';
                
                // If auth error, prompt to login
                if (error.message.includes('Authentication') || error.message.includes('Access denied')) {
                    updateAuthStatus(false, 'Authentication required');
                    setTimeout(() => {
                        if (confirm('Authentication required. Would you like to login now?')) {
                            initiateAdobeLogin();
                        }
                    }, 500);
                }
            }
        }


        // Populate the select dropdown
        function populateSelect() {
            const select = document.getElementById('programmerSelect');
            const entities = programmersData.entities || [];

            // Clear existing options (including "Loading...")
            select.innerHTML = '';
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Choose a Programmer --';
            select.appendChild(defaultOption);

            // Build options and sort A-Z by display text (numbers sort before letters with localeCompare)
            const options = entities.map((entity, index) => {
                const displayName = entity.entityData?.displayName || 'Unknown';
                const id = entity.entityData?.id || 'Unknown';
                return { value: index, text: `${displayName} - ${id}` };
            });
            options.sort((a, b) => String(a.text).localeCompare(String(b.text), undefined, { sensitivity: 'base' }));

            options.forEach(({ value, text }) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                select.appendChild(option);
            });
        }

        // Extract GUID from RegisteredApplication string
        function extractApplicationGuid(appString) {
            const match = appString.match(/^@RegisteredApplication:(.+)$/);
            return match ? match[1] : null;
        }

        // Extract Content Provider ID from string
        function extractContentProviderId(cpString) {
            const match = cpString.match(/^@ContentProvider:(.+)$/);
            return match ? match[1] : null;
        }

        // Populate content provider dropdown
        function populateContentProviders(programmerIndex) {
            const select = document.getElementById('contentProviderSelect');
            const mvpdSelect = document.getElementById('mvpdSelect');
            
            // Clear existing options
            select.innerHTML = '';
            
            // Clear MVPD dropdown when programmer changes
            mvpdSelect.innerHTML = '';
            mvpdSelect.disabled = true;
            const mvpdDefaultOption = document.createElement('option');
            mvpdDefaultOption.value = '';
            mvpdDefaultOption.textContent = '-- Select a Content Provider first --';
            mvpdSelect.appendChild(mvpdDefaultOption);
            
            if (programmerIndex === '' || !programmersData) {
                select.disabled = true;
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a Programmer first --';
                select.appendChild(defaultOption);
                return;
            }

            const entity = programmersData.entities[programmerIndex];
            const entityData = entity.entityData || {};
            const contentProviders = entityData.contentProviders || [];
            
            if (contentProviders.length === 0) {
                select.disabled = true;
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- No Content Providers available --';
                select.appendChild(defaultOption);
                return;
            }

            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Choose a Content Provider --';
            select.appendChild(defaultOption);

            // Extract IDs and sort A-Z (numbers sort before letters with localeCompare)
            const cpIds = contentProviders
                .map((cpRef) => extractContentProviderId(cpRef))
                .filter(Boolean);
            cpIds.sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));

            cpIds.forEach((cpId) => {
                const option = document.createElement('option');
                option.value = cpId;
                option.textContent = cpId;
                select.appendChild(option);
            });

            select.disabled = false;
        }

        // MVPD cache by requestor ID
        let mvpdCacheByRequestor = new Map();

        // Load MVPDs from config for a given requestor ID (content provider)
        async function loadMvpdsFromConfig(requestorId) {
            if (!requestorId || requestorId === '') {
                return new Map();
            }

            // Check cache first
            if (mvpdCacheByRequestor.has(requestorId)) {
                return mvpdCacheByRequestor.get(requestorId);
            }

            const mvpdMap = new Map();
            try {
                // Build config URL: https://sp.auth.adobe.com/api/v1/config/{requestorId}
                const configUrl = `https://sp.auth.adobe.com/api/v1/config/${encodeURIComponent(requestorId)}`;
                
                // Note: sp.auth.adobe.com doesn't allow custom headers like ap-request-id in CORS
                // Use minimal headers for this endpoint
                const headers = {
                    'Accept': 'application/xml, text/xml, */*'
                };

                const response = await fetch(configUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors',
                    headers: headers
                });

                if (!response.ok) {
                    console.warn(`Failed to load MVPDs from config for ${requestorId}:`, response.status, response.statusText);
                    return mvpdMap;
                }

                const xmlText = await response.text();
                
                // Parse XML - handle both namespaced and non-namespaced XML
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlText, 'application/xml');
                
                // Check for parsing errors
                const parseError = xml.querySelector('parsererror');
                if (parseError) {
                    console.error('XML parsing error:', parseError.textContent);
                    return mvpdMap;
                }

                // Query MVPD nodes - elements don't have namespace prefixes in the XML
                const mvpdNodes = xml.querySelectorAll('mvpds > mvpd');
                
                if (mvpdNodes.length === 0) {
                    console.warn('No MVPD nodes found in XML response');
                    return mvpdMap;
                }

                mvpdNodes.forEach(mvpdNode => {
                    // Get id element
                    const idNode = mvpdNode.querySelector('id');
                    if (!idNode) {
                        return; // Skip if no id found
                    }

                    // Get displayName element
                    const nameNode = mvpdNode.querySelector('displayName');

                    // Get isProxy element
                    const isProxyNode = mvpdNode.querySelector('isProxy');

                    // Extract values
                    const id = (idNode.textContent || '').trim();
                    if (!id) {
                        return; // Skip if id is empty
                    }

                    const nameRaw = (nameNode?.textContent || '').trim();
                    const displayName = nameRaw || id; // Use id as fallback

                    const isProxyTxt = (isProxyNode?.textContent || '').trim().toLowerCase();
                    // Default to `true` (proxied) if missing/unparseable
                    const isProxy = (isProxyTxt === 'false') ? false : true;

                    // Store in map (id => { name: displayName, isProxy })
                    if (!mvpdMap.has(id)) {
                        mvpdMap.set(id, { name: displayName, isProxy });
                    }
                });

                console.log(`Loaded ${mvpdMap.size} MVPDs from config for ${requestorId}`);
            } catch (error) {
                console.error('Error loading MVPDs from config for', requestorId, ':', error);
            }

            // Cache the result (even if empty, to avoid repeated failed requests)
            mvpdCacheByRequestor.set(requestorId, mvpdMap);
            return mvpdMap;
        }

        // Populate MVPD dropdown from config
        async function populateMvpdsFromConfig(requestorId) {
            const select = document.getElementById('mvpdSelect');
            
            // Clear existing options
            select.innerHTML = '';
            
            if (!requestorId || requestorId === '') {
                select.disabled = true;
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a Content Provider first --';
                select.appendChild(defaultOption);
                return;
            }

            // Show loading state
            select.disabled = true;
            const loadingOption = document.createElement('option');
            loadingOption.value = '';
            loadingOption.textContent = 'Loading MVPDs...';
            select.appendChild(loadingOption);

            try {
                // Load MVPDs from config
                const mvpdMap = await loadMvpdsFromConfig(requestorId);
                
                // Clear loading option
                select.innerHTML = '';
                
                if (mvpdMap.size === 0) {
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- No MVPDs available --';
                    select.appendChild(defaultOption);
                    select.disabled = true;
                    return;
                }

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Choose an MVPD --';
                select.appendChild(defaultOption);

                // Convert map to array and sort A-Z by option display text (numbers sort before letters with localeCompare)
                const entries = Array.from(mvpdMap.entries());
                entries.sort((a, b) => {
                    const aText = `${a[1].name || a[0]} (${a[0]})`;
                    const bText = `${b[1].name || b[0]} (${b[0]})`;
                    return String(aText).localeCompare(String(bText), undefined, { sensitivity: 'base' });
                });

                // Add MVPD options
                entries.forEach(([id, meta]) => {
                    const displayName = meta.name || id;
                    const isProxy = meta.isProxy !== false; // Default to true
                    
                    const option = document.createElement('option');
                    // Value = MVPD id
                    option.value = id;
                    // Text = displayName (id)
                    option.textContent = `${displayName} (${id})`;
                    
                    // Direct MVPDs (isProxy=false) in bold, Proxied in regular weight
                    if (isProxy === false) {
                        option.style.fontWeight = '700';
                    } else {
                        option.style.fontWeight = '400';
                    }
                    
                    select.appendChild(option);
                });

                select.disabled = false;
            } catch (error) {
                console.error('Error populating MVPDs:', error);
                select.innerHTML = '';
                const errorOption = document.createElement('option');
                errorOption.value = '';
                errorOption.textContent = `-- Error loading MVPDs: ${error.message} --`;
                select.appendChild(errorOption);
                select.disabled = true;
            }
        }

        // Experience Cloud base URL for IMS Org links
        const EXPERIENCE_ADOBE_BASE = 'https://experience.adobe.com';

        // Returns true if the string looks like an IMS Org ID (e.g. 8DDE41805409FD450A4C98A5@AdobeOrg)
        function isImsOrgId(str) {
            return typeof str === 'string' && /@AdobeOrg$/i.test(str.trim());
        }

        // Format metadata value for display
        function formatValue(value, depth = 0, keyName = '') {
            if (value === null) {
                return '<span class="null-value">null</span>';
            }
            
            if (value === undefined) {
                return '<span class="null-value">undefined</span>';
            }

            const type = typeof value;

            if (type === 'string') {
                // Check if this is a RegisteredApplication string
                const guid = extractApplicationGuid(value);
                if (guid) {
                    const url = `${ADOBE_CONSOLE_BASE}/rest/api/applications/${guid}`;
                    // Add click handler to ensure authentication
                    return `<a href="${url}" target="_blank" class="application-link" title="Download application data" onclick="handleApplicationLinkClick(event, '${url}')">${value}</a>`;
                }
                // IMS Org ID: link to Experience Cloud home for that org (new tab)
                if (isImsOrgId(value)) {
                    const url = `${EXPERIENCE_ADOBE_BASE}/#/@${value}/home`;
                    return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="application-link" title="Open org in Experience Cloud">${value}</a>`;
                }
                // Truncate very long strings (like certificates)
                if (value.length > 200) {
                    return `<span class="string-value">"${value.substring(0, 200)}..." (${value.length} characters)</span>`;
                }
                return `<span class="string-value">"${value}"</span>`;
            }

            if (type === 'number') {
                return `<span class="number-value">${value}</span>`;
            }

            if (type === 'boolean') {
                return `<span class="boolean-value">${value}</span>`;
            }

            if (Array.isArray(value)) {
                if (value.length === 0) {
                    return '<span class="null-value">[]</span>';
                }
                let html = '<div>';
                value.forEach((item, index) => {
                    html += `<div class="array-item"><strong>[${index}]:</strong> ${formatValue(item, depth + 1, keyName)}</div>`;
                });
                html += '</div>';
                return html;
            }

            if (type === 'object') {
                const keys = Object.keys(value);
                if (keys.length === 0) {
                    return '<span class="null-value">{}</span>';
                }
                let html = '<div>';
                keys.forEach(key => {
                    html += `<div class="object-item"><strong>${key}:</strong> ${formatValue(value[key], depth + 1, key)}</div>`;
                });
                html += '</div>';
                return html;
            }

            return String(value);
        }

        // Store applications data for current programmer
        let currentApplicationsData = null;
        let applicationDetailCacheByGuid = {};

        // Fetch applications for a programmer
        async function fetchApplicationsForProgrammer(programmerId) {
            try {
                const apiUrl = `${ADOBE_CONSOLE_BASE}/rest/api/applications?programmer=${encodeURIComponent(programmerId)}&configurationVersion=3522`;
                
                const headers = {
                    'Accept': 'application/json, text/plain, */*',
                    'Origin': 'https://cdn.experience.adobe.net',
                    'Referer': 'https://cdn.experience.adobe.net/',
                    'ap-request-id': generateRequestId()
                };

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors',
                    headers: headers
                });

                if (response.ok) {
                    const data = await response.json();
                    // Store applications indexed by GUID for quick lookup
                    currentApplicationsData = {};
                    applicationDetailCacheByGuid = {};
                    if (Array.isArray(data)) {
                        data.forEach(app => {
                            const guid = app.entityData?.id;
                            if (guid) {
                                const mergedAppData = {
                                    ...(app.entityData || app),
                                    __rawEnvelope: app
                                };
                                currentApplicationsData[guid] = mergedAppData;
                                applicationDetailCacheByGuid[guid] = mergedAppData;
                            }
                        });
                    }
                    return currentApplicationsData;
                } else {
                    console.warn('Failed to fetch applications:', response.status);
                    return null;
                }
            } catch (error) {
                console.warn('Error fetching applications:', error);
                return null;
            }
        }

        async function fetchApplicationRawByGuid(guid) {
            if (!guid) {
                return null;
            }

            const apiUrl = `${ADOBE_CONSOLE_BASE}/rest/api/applications/${encodeURIComponent(guid)}`;
            const response = await fetch(apiUrl, {
                method: 'GET',
                credentials: 'include',
                mode: 'cors',
                headers: {
                    'Accept': 'application/json, text/plain, */*',
                    'Origin': 'https://cdn.experience.adobe.net',
                    'Referer': 'https://cdn.experience.adobe.net/',
                    'ap-request-id': generateRequestId()
                }
            });

            if (!response.ok) {
                const body = await response.text().catch(() => '');
                throw new Error(`Application fetch failed (${response.status}): ${body || response.statusText}`);
            }

            const text = await response.text();
            let parsed = null;
            try {
                parsed = text ? JSON.parse(text) : null;
            } catch (error) {
                parsed = null;
            }

            const normalized = parsed?.entityData || parsed;
            if (normalized && typeof normalized === 'object') {
                applicationDetailCacheByGuid[guid] = normalized;
            }

            return {
                text: String(text || ''),
                parsed: normalized && typeof normalized === 'object' ? normalized : null
            };
        }

        async function fetchApplicationDetailsByGuid(guid) {
            if (!guid) {
                return null;
            }
            if (applicationDetailCacheByGuid[guid]) {
                return applicationDetailCacheByGuid[guid];
            }

            try {
                const raw = await fetchApplicationRawByGuid(guid);
                return raw?.parsed || null;
            } catch (error) {
                return null;
            }
        }

        async function fetchSoftwareStatementForAppGuid(guid) {
            if (!guid) {
                return null;
            }

            const cachedDetails = applicationDetailCacheByGuid[guid];
            const cachedStatement = extractSoftwareStatementFromAppData(cachedDetails);
            if (cachedStatement) {
                return cachedStatement;
            }

            let payload = null;
            try {
                payload = await fetchApplicationRawByGuid(guid);
            } catch (error) {
                return null;
            }

            if (payload?.parsed) {
                const fromParsed = extractSoftwareStatementFromAppData(payload.parsed);
                if (fromParsed) {
                    return fromParsed;
                }

                const extracted = extractJwtAndUrls(payload.parsed);
                if (extracted.jwt) {
                    return extracted.jwt;
                }

                for (const candidateUrl of extracted.urls) {
                    try {
                        const urlResponse = await fetch(candidateUrl, {
                            method: 'GET',
                            credentials: 'include',
                            mode: 'cors',
                            headers: {
                                'Accept': 'text/plain, application/json, */*'
                            }
                        });
                        if (!urlResponse.ok) {
                            continue;
                        }
                        const urlText = await urlResponse.text();
                        const jwtMatchFromUrl = String(urlText || '').match(/[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+/);
                        if (jwtMatchFromUrl && isProbablyJwt(jwtMatchFromUrl[0])) {
                            return jwtMatchFromUrl[0];
                        }
                    } catch (error) {
                        // Ignore failed URL dereference attempts
                    }
                }
            }

            const text = String(payload?.text || '').trim();
            const jwtMatch = text.match(/[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+/);
            if (jwtMatch && isProbablyJwt(jwtMatch[0])) {
                return jwtMatch[0];
            }

            return null;
        }

        async function enrichPremiumAppsWithSoftwareStatements(premiumApps) {
            const entries = Object.entries(premiumApps || {});
            for (const [, appInfo] of entries) {
                if (!appInfo || appInfo.softwareStatement) {
                    continue;
                }

                const details = await fetchApplicationDetailsByGuid(appInfo.guid);
                if (details) {
                    appInfo.appData = details;
                    appInfo.softwareStatement = extractSoftwareStatementFromAppData(details);
                }

                if (!appInfo.softwareStatement) {
                    appInfo.softwareStatement = await fetchSoftwareStatementForAppGuid(appInfo.guid);
                }
            }
        }

        // PASS Console URL for programmer applications (legacy / no scopes)
        const PASS_CONSOLE_PROGRAMMER_APPLICATIONS = 'https://experience.adobe.com/#/@adobepass/pass/authentication/release-production/programmers';

        // Format applications with scope information. Only applications that have scopes are displayed.
        // Legacy (no-scope) applications are not listed; a single link to PASS Console is shown instead.
        function formatApplicationsWithScopes(applicationsArray, applicationsData, programmerId) {
            if (!Array.isArray(applicationsArray) || applicationsArray.length === 0) {
                return '<span class="null-value">[]</span>';
            }

            let html = '<div>';
            
            // Separate applications with scopes from those without (we only display the former; legacy get a single link)
            const appsWithScopes = [];
            const appsWithoutScopes = [];
            
            applicationsArray.forEach((appRef, index) => {
                const guid = extractApplicationGuid(appRef);
                if (guid && applicationsData && applicationsData[guid]) {
                    const appData = applicationsData[guid];
                    const scopes = appData.scopes;
                    const appName = appData.name || 'Unknown';
                    
                    if (scopes && Array.isArray(scopes) && scopes.length > 0) {
                        appsWithScopes.push({ index, appRef, guid, appData, appName, scopes });
                    } else {
                        appsWithoutScopes.push({ index, appRef, guid, appData, appName });
                    }
                } else {
                    appsWithoutScopes.push({ index, appRef, guid: null, appData: null, appName: null });
                }
            });

            // Only display applications that have scopes (DCR-protected; ESM, Degradation, REST V2)
            if (appsWithScopes.length > 0) {
                html += '<div style="margin-bottom: var(--spectrum-global-dimension-size-200);"><strong style="color: var(--spectrum-global-color-green-600); font-size: 15px; font-weight: 700;">‚≠ê Applications with Scopes (Premium Features):</strong></div>';
                appsWithScopes.forEach(({ index, appRef, guid, appName, scopes }, arrayIndex) => {
                    const url = `${ADOBE_CONSOLE_BASE}/rest/api/applications/${guid}`;
                    const bgColor = arrayIndex % 2 === 0 ? '#2d9d78' : '#1e7a5e';
                    const textColor = 'var(--spectrum-global-color-gray-50)';
                    html += `<div class="array-item" style="background: ${bgColor}; border-left: 3px solid var(--spectrum-global-color-green-600); padding: var(--spectrum-global-dimension-size-100); margin-bottom: var(--spectrum-global-dimension-size-100); border-radius: var(--spectrum-alias-border-radius-regular);">`;
                    html += `<strong>[${index}]:</strong> `;
                    html += `<a href="${url}" target="_blank" title="Download application data: ${appRef}" onclick="handleApplicationLinkClick(event, '${url}')" style="color: ${textColor}; text-decoration: underline; font-weight: 600; transition: opacity 130ms ease-out; font-size: 15px;">${appName}</a>`;
                    html += `<div style="margin-top: var(--spectrum-global-dimension-size-75); margin-left: var(--spectrum-global-dimension-size-250);">`;
                    html += `<strong style="color: ${textColor}; font-weight: 700;">Scopes:</strong> `;
                    html += `<span style="background: var(--spectrum-global-color-green-600); padding: var(--spectrum-global-dimension-size-25) var(--spectrum-global-dimension-size-100); border-radius: var(--spectrum-alias-border-radius-small); margin: var(--spectrum-global-dimension-size-25); display: inline-block; color: ${textColor}; font-weight: 600;">${scopes.join('</span> <span style="background: var(--spectrum-global-color-green-600); padding: var(--spectrum-global-dimension-size-25) var(--spectrum-global-dimension-size-100); border-radius: var(--spectrum-alias-border-radius-small); margin: var(--spectrum-global-dimension-size-25); display: inline-block; color: ' + textColor + '; font-weight: 600;">')}</span>`;
                    html += `</div></div>`;
                });
            }

            // Single link to PASS Console for legacy applications (no per-app list)
            if (appsWithoutScopes.length > 0 && programmerId) {
                const legacyUrl = `${PASS_CONSOLE_PROGRAMMER_APPLICATIONS}/${encodeURIComponent(programmerId)}/applications`;
                html += '<div style="margin-top: var(--spectrum-global-dimension-size-250); margin-bottom: var(--spectrum-global-dimension-size-200);">';
                html += `<a href="${legacyUrl}" target="_blank" rel="noopener noreferrer" style="color: var(--spectrum-global-color-blue-600); text-decoration: underline; font-size: 15px; font-weight: 600;">View Legacy Applications (No Scopes), in PASS Console</a>`;
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function normalizeScope(scope) {
            return String(scope || '').trim().toLowerCase();
        }

        function isProbablyJwt(value) {
            if (!value) {
                return false;
            }
            const token = String(value).trim();
            if (token.length < 60) {
                return false;
            }
            const parts = token.split('.');
            if (parts.length !== 3) {
                return false;
            }
            return /^[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+$/.test(token);
        }

        function extractJwtAndUrls(value) {
            const seen = new Set();
            const jwtCandidates = [];
            const urlCandidates = [];
            const stack = [{ node: value, path: '' }];

            while (stack.length > 0) {
                const { node, path } = stack.pop();

                if (typeof node === 'string') {
                    const trimmed = node.trim();
                    if (isProbablyJwt(trimmed)) {
                        const lowerPath = String(path || '').toLowerCase();
                        let score = 0;
                        if (lowerPath.includes('software') && lowerPath.includes('statement')) {
                            score += 100;
                        }
                        if (lowerPath.includes('software_statement') || lowerPath.includes('softwarestatement')) {
                            score += 100;
                        }
                        if (lowerPath.includes('jwt')) {
                            score += 10;
                        }
                        if (trimmed.length > 300) {
                            score += 5;
                        }
                        jwtCandidates.push({ score, value: trimmed, path });
                    }

                    if (/^https?:\/\//i.test(trimmed) && /software/i.test(trimmed) && /statement/i.test(trimmed)) {
                        urlCandidates.push(trimmed);
                    }
                    continue;
                }

                if (!node || typeof node !== 'object') {
                    continue;
                }
                if (seen.has(node)) {
                    continue;
                }
                seen.add(node);

                if (Array.isArray(node)) {
                    node.forEach((item, index) => {
                        stack.push({ node: item, path: `${path}[${index}]` });
                    });
                    continue;
                }

                Object.entries(node).forEach(([key, nested]) => {
                    const nestedPath = path ? `${path}.${key}` : key;
                    stack.push({ node: nested, path: nestedPath });
                });
            }

            jwtCandidates.sort((a, b) => b.score - a.score);
            return {
                jwt: jwtCandidates[0]?.value || '',
                jwtPath: jwtCandidates[0]?.path || '',
                urls: urlCandidates
            };
        }

        function getScopesFromApplication(appData) {
            if (!appData || !Array.isArray(appData.scopes)) {
                return [];
            }
            return appData.scopes
                .map((scope) => normalizeScope(scope))
                .filter(Boolean);
        }

        function extractSoftwareStatementFromAppData(appData) {
            const directCandidates = [
                appData?.softwareStatement,
                appData?.software_statement,
                appData?.softwarestatement,
                appData?.software?.statement,
                appData?.dcr?.softwareStatement,
                appData?.credentials?.softwareStatement
            ];

            let fallbackCandidate = null;
            for (const candidate of directCandidates) {
                if (typeof candidate === 'string' && candidate.trim() !== '') {
                    const trimmed = candidate.trim();
                    if (isProbablyJwt(trimmed)) {
                        return trimmed;
                    }
                    if (!fallbackCandidate) {
                        fallbackCandidate = trimmed;
                    }
                }
            }

            const extracted = extractJwtAndUrls(appData);
            return extracted.jwt || fallbackCandidate || null;
        }

        function findPremiumServiceApplications(applicationsArray, applicationsData) {
            const services = {
                degradation: null,
                esm: null,
                restV2: null
            };

            if (!Array.isArray(applicationsArray) || !applicationsData) {
                return services;
            }

            for (let index = 0; index < applicationsArray.length; index += 1) {
                const appRef = applicationsArray[index];
                const guid = extractApplicationGuid(appRef);
                if (!guid || !applicationsData[guid]) {
                    continue;
                }

                const appData = applicationsData[guid];
                const scopes = getScopesFromApplication(appData);
                if (scopes.length === 0) {
                    continue;
                }

                const appInfo = {
                    index,
                    appRef,
                    guid,
                    appData,
                    appName: appData.name || appData.displayName || guid,
                    scopes,
                    softwareStatement: extractSoftwareStatementFromAppData(appData)
                };

                if (!services.degradation && scopes.includes(PREMIUM_SERVICE_SCOPE_BY_KEY.degradation)) {
                    services.degradation = appInfo;
                }
                if (!services.esm && scopes.includes(PREMIUM_SERVICE_SCOPE_BY_KEY.esm)) {
                    services.esm = appInfo;
                }
                if (!services.restV2 && scopes.includes(PREMIUM_SERVICE_SCOPE_BY_KEY.restV2)) {
                    services.restV2 = appInfo;
                }

                if (services.degradation && services.esm && services.restV2) {
                    break;
                }
            }

            return services;
        }

        function getDcrCacheKey(programmerId, appGuid) {
            return `${DCR_CACHE_PREFIX}:${programmerId}:${appGuid}`;
        }

        function loadDcrCache(programmerId, appGuid) {
            try {
                const raw = localStorage.getItem(getDcrCacheKey(programmerId, appGuid));
                if (!raw) {
                    return null;
                }
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') {
                    return null;
                }
                const normalized = {
                    ...parsed,
                    clientId: parsed.clientId || parsed.client_id || '',
                    clientSecret: parsed.clientSecret || parsed.client_secret || '',
                    accessToken: parsed.accessToken || parsed.access_token || '',
                    tokenExpiresAt: parsed.tokenExpiresAt || parsed.expires_at || parsed.token_expires_at || 0
                };
                return normalized;
            } catch (error) {
                return null;
            }
        }

        function saveDcrCache(programmerId, appGuid, value) {
            try {
                const normalized = {
                    ...value,
                    clientId: value?.clientId || value?.client_id || '',
                    clientSecret: value?.clientSecret || value?.client_secret || '',
                    accessToken: value?.accessToken || value?.access_token || '',
                    tokenExpiresAt: value?.tokenExpiresAt || value?.expires_at || 0
                };
                localStorage.setItem(getDcrCacheKey(programmerId, appGuid), JSON.stringify(normalized));
            } catch (error) {
                console.warn('Unable to save DCR cache:', error);
            }
        }

        function clearDcrCache(programmerId, appGuid) {
            try {
                localStorage.removeItem(getDcrCacheKey(programmerId, appGuid));
            } catch (error) {
                console.warn('Unable to clear DCR cache:', error);
            }
        }

        async function registerClientWithSoftwareStatement(softwareStatement) {
            const attempts = [];

            attempts.push(async () => {
                const payload = {
                    software_statement: softwareStatement,
                    grant_types: ['client_credentials'],
                    token_endpoint_auth_method: 'client_secret_post'
                };
                const response = await fetch(`${ADOBE_SP_BASE}/o/client/register`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                const text = await response.text().catch(() => '');
                let parsed = null;
                try {
                    parsed = text ? JSON.parse(text) : {};
                } catch (error) {
                    parsed = {};
                }
                if (!response.ok) {
                    throw new Error(`DCR JSON register failed (${response.status}): ${text || response.statusText}`);
                }
                return parsed || {};
            });

            attempts.push(async () => {
                const body = new URLSearchParams();
                body.set('software_statement', softwareStatement);
                const response = await fetch(`${ADOBE_SP_BASE}/o/client/register`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Accept': 'application/json'
                    },
                    body: body.toString()
                });
                const text = await response.text().catch(() => '');
                let parsed = null;
                try {
                    parsed = text ? JSON.parse(text) : {};
                } catch (error) {
                    parsed = {};
                }
                if (!response.ok) {
                    throw new Error(`DCR form register failed (${response.status}): ${text || response.statusText}`);
                }
                return parsed || {};
            });

            let lastError = 'DCR registration failed.';
            for (const attempt of attempts) {
                try {
                    const data = await attempt();
                    const clientId = data.client_id || data.clientId || data.clientID;
                    const clientSecret = data.client_secret || data.clientSecret || data.clientSECRET;
                    if (!clientId || !clientSecret) {
                        throw new Error('DCR response missing client_id/client_secret.');
                    }
                    return {
                        clientId,
                        clientSecret
                    };
                } catch (error) {
                    lastError = error?.message || String(error);
                }
            }
            throw new Error(lastError);
        }

        async function requestClientCredentialsToken(clientId, clientSecret) {
            const attempts = [];

            attempts.push(async () => {
                const tokenUrl = `${ADOBE_SP_BASE}/o/client/token?grant_type=client_credentials&client_id=${encodeURIComponent(clientId)}&client_secret=${encodeURIComponent(clientSecret)}`;
                const response = await fetch(tokenUrl, {
                    method: 'POST',
                    mode: 'cors'
                });
                const text = await response.text().catch(() => '');
                let parsed = null;
                try {
                    parsed = text ? JSON.parse(text) : {};
                } catch (error) {
                    parsed = {};
                }
                if (!response.ok) {
                    throw new Error(`DCR token query failed (${response.status}): ${text || response.statusText}`);
                }
                return parsed || {};
            });

            attempts.push(async () => {
                const body = new URLSearchParams();
                body.set('grant_type', 'client_credentials');
                body.set('client_id', clientId);
                body.set('client_secret', clientSecret);
                const response = await fetch(`${ADOBE_SP_BASE}/o/client/token`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Accept': 'application/json'
                    },
                    body: body.toString()
                });
                const text = await response.text().catch(() => '');
                let parsed = null;
                try {
                    parsed = text ? JSON.parse(text) : {};
                } catch (error) {
                    parsed = {};
                }
                if (!response.ok) {
                    throw new Error(`DCR token form failed (${response.status}): ${text || response.statusText}`);
                }
                return parsed || {};
            });

            let lastError = 'Token request failed.';
            for (const attempt of attempts) {
                try {
                    const data = await attempt();
                    const accessToken = data.access_token || data.accessToken;
                    if (!accessToken) {
                        throw new Error('Token response missing access_token');
                    }

                    const expiresInSeconds = Number(data.expires_in || data.expiresIn);
                    const ttlSeconds = Number.isFinite(expiresInSeconds) && expiresInSeconds > 0
                        ? expiresInSeconds
                        : 6 * 60 * 60;

                    return {
                        accessToken,
                        tokenExpiresAt: Date.now() + (ttlSeconds * 1000)
                    };
                } catch (error) {
                    lastError = error?.message || String(error);
                }
            }

            throw new Error(lastError);
        }

        async function ensureDcrAccessToken(programmerId, appInfo, forceRefresh = false) {
            if (!programmerId) {
                throw new Error('Programmer ID is required');
            }
            if (!appInfo || !appInfo.guid) {
                throw new Error('Registered application details are missing');
            }

            const promiseKey = getDcrCacheKey(programmerId, appInfo.guid);
            if (!forceRefresh && dcrEnsureTokenPromiseByKey.has(promiseKey)) {
                return dcrEnsureTokenPromiseByKey.get(promiseKey);
            }

            const workPromise = (async () => {
                let cache = loadDcrCache(programmerId, appInfo.guid) || {};

                if (!cache.clientId || !cache.clientSecret) {
                    if (!appInfo.softwareStatement) {
                        const softwareStatement = await fetchSoftwareStatementForAppGuid(appInfo.guid);
                        if (softwareStatement) {
                            appInfo.softwareStatement = softwareStatement;
                        }
                    }
                    if (!appInfo.softwareStatement) {
                        throw new Error(`No software statement found on app ${appInfo.appName}`);
                    }
                    const registered = await registerClientWithSoftwareStatement(appInfo.softwareStatement);
                    cache.clientId = registered.clientId;
                    cache.clientSecret = registered.clientSecret;
                }

                const isTokenMissing = !cache.accessToken || !cache.tokenExpiresAt;
                const isTokenExpired = Date.now() >= (Number(cache.tokenExpiresAt) - (60 * 1000));

                if (forceRefresh || isTokenMissing || isTokenExpired) {
                    const token = await requestClientCredentialsToken(cache.clientId, cache.clientSecret);
                    cache.accessToken = token.accessToken;
                    cache.tokenExpiresAt = token.tokenExpiresAt;
                }

                saveDcrCache(programmerId, appInfo.guid, cache);
                return cache.accessToken;
            })();

            dcrEnsureTokenPromiseByKey.set(promiseKey, workPromise);
            try {
                return await workPromise;
            } finally {
                if (dcrEnsureTokenPromiseByKey.get(promiseKey) === workPromise) {
                    dcrEnsureTokenPromiseByKey.delete(promiseKey);
                }
            }
        }

        async function fetchWithPremiumAuth(programmerId, appInfo, url, options = {}, retryStage = 'refresh') {
            const token = await ensureDcrAccessToken(programmerId, appInfo, false);
            const headers = new Headers(options.headers || {});
            headers.set('Authorization', `Bearer ${token}`);
            if (!headers.has('Accept')) {
                headers.set('Accept', 'application/json');
            }

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (response.status === 401 && retryStage === 'refresh') {
                await ensureDcrAccessToken(programmerId, appInfo, true);
                return fetchWithPremiumAuth(programmerId, appInfo, url, options, 'reprovision');
            }

            if (response.status === 401 && retryStage === 'reprovision') {
                clearDcrCache(programmerId, appInfo.guid);
                await ensureDcrAccessToken(programmerId, appInfo, true);
                return fetchWithPremiumAuth(programmerId, appInfo, url, options, 'none');
            }

            return response;
        }

        function toggleCollapsibleSection(headerElement, containerElement) {
            if (!headerElement || !containerElement) {
                return;
            }
            if (containerElement.classList.contains('collapsed')) {
                containerElement.classList.remove('collapsed');
                headerElement.classList.remove('collapsed');
            } else {
                containerElement.classList.add('collapsed');
                headerElement.classList.add('collapsed');
            }
        }

        function clearPremiumServicesContainer() {
            const premiumContainer = document.getElementById('premiumServicesContainer');
            if (premiumContainer) {
                premiumContainer.innerHTML = '';
            }
        }

        function createPremiumServiceSection(serviceKey, appInfo) {
            const serviceClassByKey = {
                degradation: 'service-degradation',
                esm: 'service-esm',
                restV2: 'service-rest-v2'
            };

            const section = document.createElement('div');
            section.className = `metadata-section premium-service-section ${serviceClassByKey[serviceKey] || ''}`;

            const title = PREMIUM_SERVICE_TITLE_BY_KEY[serviceKey] || serviceKey;
            const headerTitle = `${title} w/ '${appInfo.appName}'`;

            section.innerHTML = `
                <h2>
                    <span>${escapeHtml(headerTitle)}</span>
                    <span class="collapse-icon">‚ñº</span>
                </h2>
                <div class="metadata-container">
                    <div class="service-actions">
                        <button class="service-refresh-btn">Refresh ${escapeHtml(title)}</button>
                    </div>
                    <div class="service-content">
                        <div class="loading">Loading ${escapeHtml(title)} data...</div>
                    </div>
                </div>
            `;

            const header = section.querySelector('h2');
            const container = section.querySelector('.metadata-container');
            header.addEventListener('click', () => toggleCollapsibleSection(header, container));

            return {
                section,
                contentElement: section.querySelector('.service-content'),
                refreshButton: section.querySelector('.service-refresh-btn')
            };
        }

        function statusClassForValue(status) {
            const normalized = String(status || '').toUpperCase();
            if (normalized === 'APPLIED') {
                return 'status-applied';
            }
            if (normalized === 'PENDING') {
                return 'status-pending';
            }
            return 'status-none';
        }

        function collectDegradationStatusEntries(node, path = [], results = []) {
            if (Array.isArray(node)) {
                node.forEach((item, index) => collectDegradationStatusEntries(item, path.concat(`[${index}]`), results));
                return results;
            }

            if (!node || typeof node !== 'object') {
                return results;
            }

            const hasStatus = Object.prototype.hasOwnProperty.call(node, 'degradation-measure-status');
            const hasEnable = Object.prototype.hasOwnProperty.call(node, 'degradation-measure-enable');

            if (hasStatus || hasEnable) {
                results.push({
                    path: path.join(' > '),
                    status: node['degradation-measure-status'],
                    enabled: node['degradation-measure-enable'],
                    ttl: node.ttl,
                    activationTime: node['activation-time'],
                    errMsg: node['err-msg'],
                    id: node.id,
                    programmer: node.programmer,
                    mvpd: node.mvpd,
                    channel: node.channel
                });
            }

            Object.keys(node).forEach((key) => {
                collectDegradationStatusEntries(node[key], path.concat(key), results);
            });

            return results;
        }

        function formatDegradationStatusEntries(entries) {
            if (!entries.length) {
                return '<span class="null-value">No degradation status entries returned.</span>';
            }

            let html = '<div>';
            entries.forEach((entry, index) => {
                const statusValue = String(entry.status || 'UNKNOWN').toUpperCase();
                const statusClass = statusClassForValue(statusValue);
                html += `<div class="array-item"><strong>[${index}]</strong> `;
                html += `<span class="status-pill ${statusClass}">${escapeHtml(statusValue)}</span>`;
                if (entry.enabled !== undefined) {
                    html += ` enabled=<strong>${escapeHtml(String(entry.enabled))}</strong>`;
                }
                if (entry.ttl !== undefined && entry.ttl !== null && entry.ttl !== '') {
                    html += ` ttl=<strong>${escapeHtml(String(entry.ttl))}</strong>`;
                }
                if (entry.id) {
                    html += ` id=<strong>${escapeHtml(String(entry.id))}</strong>`;
                }
                if (entry.channel) {
                    html += ` channel=<strong>${escapeHtml(String(entry.channel))}</strong>`;
                }
                if (entry.mvpd) {
                    html += ` mvpd=<strong>${escapeHtml(String(entry.mvpd))}</strong>`;
                }
                if (entry.programmer) {
                    html += ` programmer=<strong>${escapeHtml(String(entry.programmer))}</strong>`;
                }
                if (entry.activationTime) {
                    html += `<div class="object-item"><strong>activation-time:</strong> ${escapeHtml(String(entry.activationTime))}</div>`;
                }
                if (entry.errMsg) {
                    html += `<div class="object-item"><strong>err-msg:</strong> ${escapeHtml(String(entry.errMsg))}</div>`;
                }
                if (entry.path) {
                    html += `<div class="object-item"><strong>path:</strong> ${escapeHtml(entry.path)}</div>`;
                }
                html += '</div>';
            });
            html += '</div>';
            return html;
        }

        async function fetchDegradationStatusCall(programmerId, appInfo, callKey, selectedMvpd) {
            const params = new URLSearchParams();
            params.set('programmer', programmerId);
            if (selectedMvpd) {
                params.set('mvpd', selectedMvpd);
            }
            params.set('format', 'json');

            const scopedUrl = `${ADOBE_MGMT_BASE}/control/v3/degradation/${encodeURIComponent(programmerId)}/${callKey}?${params.toString()}`;
            let response = await fetchWithPremiumAuth(programmerId, appInfo, scopedUrl, {
                method: 'GET'
            });
            let text = await response.text();

            if (!response.ok && response.status === 404) {
                const legacyUrl = `${ADOBE_MGMT_BASE}/control/v3/degradation/${callKey}?${params.toString()}`;
                response = await fetchWithPremiumAuth(programmerId, appInfo, legacyUrl, {
                    method: 'GET'
                });
                text = await response.text();
            }

            if (!response.ok) {
                return {
                    ok: false,
                    error: `HTTP ${response.status} ${response.statusText}`,
                    body: text
                };
            }

            let data = null;
            try {
                data = text ? JSON.parse(text) : null;
            } catch (error) {
                data = null;
            }

            return {
                ok: true,
                data,
                rawText: text
            };
        }

        async function loadDegradationService(programmerId, appInfo, contentElement, refreshButton, requestToken) {
            if (!contentElement) {
                return;
            }
            if (refreshButton) {
                refreshButton.disabled = true;
            }

            const selectedMvpd = document.getElementById('mvpdSelect')?.value?.trim();
            const calls = [
                { key: 'authnAll', label: 'Authenticate All - Status' },
                { key: 'authzAll', label: 'Authorize All - Status' },
                { key: 'authzNone', label: 'Authorize None - Status' }
            ];

            contentElement.innerHTML = '<div class="loading">Loading degradation status calls...</div>';

            try {
                const responses = await Promise.all(calls.map(async (callInfo) => {
                    const result = await fetchDegradationStatusCall(programmerId, appInfo, callInfo.key, selectedMvpd);
                    return {
                        ...callInfo,
                        ...result
                    };
                }));

                if (requestToken !== activeMetadataRequestToken) {
                    return;
                }

                let html = '';
                responses.forEach((result) => {
                    if (!result.ok) {
                        html += `
                            <div class="metadata-item">
                                <div class="metadata-key">${escapeHtml(result.label)}</div>
                                <div class="metadata-value service-error">${escapeHtml(result.error)}
${escapeHtml(result.body || '')}</div>
                            </div>
                        `;
                        return;
                    }

                    const entries = collectDegradationStatusEntries(result.data || {});
                    const formattedValue = entries.length > 0
                        ? formatDegradationStatusEntries(entries)
                        : formatValue(result.data || result.rawText || 'No data');

                    html += `
                        <div class="metadata-item">
                            <div class="metadata-key">${escapeHtml(result.label)}</div>
                            <div class="metadata-value">${formattedValue}</div>
                        </div>
                    `;
                });

                contentElement.innerHTML = html;
            } catch (error) {
                if (requestToken !== activeMetadataRequestToken) {
                    return;
                }
                contentElement.innerHTML = `<div class="service-error">${escapeHtml(error.message)}</div>`;
            } finally {
                if (refreshButton) {
                    refreshButton.disabled = false;
                }
            }
        }

        const ESM_METRIC_COLUMNS = new Set([
            'authn-attempts', 'authn-successful', 'authn-pending', 'authn-failed',
            'clientless-tokens', 'clientless-failures',
            'authz-attempts', 'authz-successful', 'authz-failed', 'authz-rejected',
            'authz-latency', 'media-tokens',
            'unique-accounts', 'unique-sessions', 'count'
        ]);

        const ESM_DATE_PARTS = ['year', 'month', 'day', 'hour', 'minute'];

        function isoTimestamp(date) {
            return new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');
        }

        function esmPartsToUtcMs(row) {
            const year = Number(row?.year ?? 1970);
            const month = Number(row?.month ?? 1);
            const day = Number(row?.day ?? 1);
            const hour = Number(row?.hour ?? 0);
            const minute = Number(row?.minute ?? 0);

            return Date.UTC(
                Number.isFinite(year) ? year : 1970,
                Number.isFinite(month) ? month - 1 : 0,
                Number.isFinite(day) ? day : 1,
                Number.isFinite(hour) ? hour : 0,
                Number.isFinite(minute) ? minute : 0
            ) - (ESM_SOURCE_UTC_OFFSET_MINUTES * 60 * 1000);
        }

        function buildEsmDateLabel(row) {
            const date = new Date(esmPartsToUtcMs(row));
            return date.toLocaleString('en-US', {
                timeZone: CLIENT_TIMEZONE,
                month: '2-digit',
                day: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                timeZoneName: 'short'
            });
        }

        function getLastModifiedSourceTimezone(rawHttpDate) {
            if (rawHttpDate == null || typeof rawHttpDate !== 'string') {
                return '';
            }
            const tail = rawHttpDate.trim().split(/\s+/).pop();
            if (!tail) {
                return '';
            }
            if (/^[A-Z]{2,4}$/i.test(tail)) {
                return tail.toUpperCase();
            }
            if (/^[+-]\d{4}$/.test(tail)) {
                return tail;
            }
            return '';
        }

        function formatLastModifiedForDisplay(rawHttpDate) {
            if (rawHttpDate == null || String(rawHttpDate).trim() === '') {
                return rawHttpDate;
            }
            const date = new Date(rawHttpDate);
            if (Number.isNaN(date.getTime())) {
                return rawHttpDate;
            }

            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: CLIENT_TIMEZONE,
                month: '2-digit',
                day: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hourCycle: 'h23',
                timeZoneName: 'short'
            });

            const parts = formatter.formatToParts(date);
            const getPart = (type) => parts.find((part) => part.type === type)?.value ?? '';
            const tzName = getPart('timeZoneName');
            return `${getPart('month')}/${getPart('day')}/${getPart('year')} ${getPart('hour')}:${getPart('minute')}:${getPart('second')} ${tzName || CLIENT_TIMEZONE}`;
        }

        function esmToNumber(value) {
            const number = Number(value);
            return Number.isFinite(number) ? number : null;
        }

        function esmSafeRate(numerator, denominator) {
            const n = esmToNumber(numerator);
            const d = esmToNumber(denominator);
            if (n == null || d == null || d <= 0) {
                return null;
            }
            const rate = n / d;
            return Number.isFinite(rate) ? rate : null;
        }

        function esmFormatPercent(rate) {
            if (rate == null) {
                return '‚Äî';
            }
            return `${(rate * 100).toFixed(2)}%`;
        }

        function createEsmCell(value) {
            const cell = document.createElement('td');
            const text = value == null ? '' : String(value);
            cell.textContent = text;
            cell.title = text;
            return cell;
        }

        function sanitizeFileSegment(value, fallback = 'na') {
            const normalized = String(value || '')
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9._-]+/g, '-')
                .replace(/^-+|-+$/g, '');
            return normalized || fallback;
        }

        function buildEsmCsvFileName(programmerId) {
            const requestorId = document.getElementById('contentProviderSelect')?.value?.trim();
            const mvpdId = document.getElementById('mvpdSelect')?.value?.trim();
            const now = new Date();
            const timestamp = [
                now.getFullYear().toString(),
                String(now.getMonth() + 1).padStart(2, '0'),
                String(now.getDate()).padStart(2, '0'),
                String(now.getHours()).padStart(2, '0'),
                String(now.getMinutes()).padStart(2, '0'),
                String(now.getSeconds()).padStart(2, '0')
            ].join('');

            return `esm_${sanitizeFileSegment(programmerId, 'programmer')}_${sanitizeFileSegment(requestorId, 'all-requestors')}_${sanitizeFileSegment(mvpdId, 'all-mvpds')}_${timestamp}.csv`;
        }

        function getDefaultEsmSortStack() {
            return [{ col: 'DATE', dir: 'DESC' }];
        }

        function getEsmCellValue(row, columnKey, context) {
            if (columnKey === 'DATE') {
                return esmPartsToUtcMs(row);
            }

            if (context.hasAuthN && columnKey === 'AuthN Success') {
                const rate = esmSafeRate(row['authn-successful'], row['authn-attempts']);
                return rate == null ? -1 : rate;
            }

            if (context.hasAuthZ && columnKey === 'AuthZ Success') {
                const rate = esmSafeRate(row['authz-successful'], row['authz-attempts']);
                return rate == null ? -1 : rate;
            }

            if (columnKey === 'COUNT') {
                const value = esmToNumber(row.count);
                return value == null ? 0 : value;
            }

            const rawValue = row[columnKey];
            if (rawValue == null) {
                return '';
            }

            if (typeof rawValue === 'number' && Number.isFinite(rawValue)) {
                return rawValue;
            }

            const converted = esmToNumber(rawValue);
            if (converted != null) {
                return converted;
            }

            return String(rawValue).toLowerCase();
        }

        function sortEsmRows(rows, sortStack, context) {
            const stack = Array.isArray(sortStack) && sortStack.length > 0
                ? sortStack
                : getDefaultEsmSortStack();

            return [...rows].sort((left, right) => {
                for (const sortRule of stack) {
                    const factor = sortRule.dir === 'ASC' ? 1 : -1;
                    const leftValue = getEsmCellValue(left, sortRule.col, context);
                    const rightValue = getEsmCellValue(right, sortRule.col, context);

                    if (leftValue < rightValue) {
                        return -1 * factor;
                    }
                    if (leftValue > rightValue) {
                        return 1 * factor;
                    }
                }

                return getEsmCellValue(right, 'DATE', context) - getEsmCellValue(left, 'DATE', context);
            });
        }

        function renderEsmTableBody(state) {
            const { tbody, data, hasAuthN, hasAuthZ, hasCount, displayColumns } = state;
            tbody.innerHTML = '';

            data.forEach((row) => {
                const tableRow = document.createElement('tr');
                tableRow.appendChild(createEsmCell(buildEsmDateLabel(row)));

                if (hasAuthN) {
                    tableRow.appendChild(createEsmCell(esmFormatPercent(esmSafeRate(row['authn-successful'], row['authn-attempts']))));
                }
                if (hasAuthZ) {
                    tableRow.appendChild(createEsmCell(esmFormatPercent(esmSafeRate(row['authz-successful'], row['authz-attempts']))));
                }
                if (!hasAuthN && !hasAuthZ && hasCount) {
                    tableRow.appendChild(createEsmCell(row.count));
                }

                displayColumns.forEach((column) => {
                    tableRow.appendChild(createEsmCell(row[column] ?? ''));
                });

                tbody.appendChild(tableRow);
            });
        }

        function refreshEsmHeaderStates(state) {
            if (!state || !state.thead) {
                return;
            }
            state.thead.querySelectorAll('th').forEach((headerCell) => {
                if (typeof headerCell._updateState === 'function') {
                    headerCell._updateState();
                }
            });
        }

        function downloadEsmCsv(rows, sortRule, context, fileName) {
            if (!Array.isArray(rows) || rows.length === 0) {
                return;
            }

            const sortedRows = sortEsmRows(rows, sortRule ? [sortRule] : getDefaultEsmSortStack(), context);
            const headers = Object.keys(sortedRows[0]);
            const lines = [
                headers.join(','),
                ...sortedRows.map((row) => headers
                    .map((header) => `"${String(row[header] ?? '').replace(/"/g, '""')}"`)
                    .join(','))
            ];

            const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
            const blobUrl = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = blobUrl;
            downloadLink.download = fileName || 'esm-report.csv';
            downloadLink.click();
            URL.revokeObjectURL(blobUrl);
        }

        function renderEsmReportTable(contentElement, reportRows, lastModified, programmerId) {
            if (!Array.isArray(reportRows) || reportRows.length === 0) {
                contentElement.innerHTML = '<div class="metadata-item"><div class="metadata-key">ESM</div><div class="metadata-value"><span class="null-value">No rows returned.</span></div></div>';
                return;
            }

            contentElement.innerHTML = `
                <div class="esm-table-wrapper">
                    <table class="esm-table">
                        <thead><tr></tr></thead>
                        <tbody></tbody>
                        <tfoot>
                            <tr>
                                <td class="esm-footer-cell">
                                    <div class="esm-footer">
                                        <a href="#" class="esm-csv-link">CSV</a>
                                        <span class="esm-last-modified"></span>
                                    </div>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `;

            const table = contentElement.querySelector('.esm-table');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');

            const firstRow = reportRows[0];
            const hasAuthN = firstRow['authn-attempts'] != null && firstRow['authn-successful'] != null;
            const hasAuthZ = firstRow['authz-attempts'] != null && firstRow['authz-successful'] != null;
            const hasCount = firstRow.count != null;
            const displayColumns = Object.keys(firstRow).filter((column) =>
                !ESM_METRIC_COLUMNS.has(column) &&
                !ESM_DATE_PARTS.includes(column) &&
                column !== 'media-company'
            );

            const headers = ['DATE'];
            if (hasAuthN) {
                headers.push('AuthN Success');
            }
            if (hasAuthZ) {
                headers.push('AuthZ Success');
            }
            if (!hasAuthN && !hasAuthZ && hasCount) {
                headers.push('COUNT');
            }
            headers.push(...displayColumns);

            const context = { hasAuthN, hasAuthZ };
            const state = {
                thead,
                tbody,
                data: reportRows,
                sortStack: getDefaultEsmSortStack(),
                hasAuthN,
                hasAuthZ,
                hasCount,
                displayColumns,
                context
            };

            const headerRow = thead.querySelector('tr');
            headers.forEach((header) => {
                const th = document.createElement('th');
                th.style.cursor = 'pointer';
                th.textContent = header;

                const icon = document.createElement('span');
                icon.className = 'sort-icon';
                icon.style.marginLeft = '6px';
                th.appendChild(icon);

                th._updateState = () => {
                    const isActive = state.sortStack[0]?.col === header;
                    th.classList.toggle('active-sort', isActive);
                    icon.textContent = isActive ? (state.sortStack[0].dir === 'ASC' ? '‚ñ≤' : '‚ñº') : '';
                };

                th.addEventListener('click', (event) => {
                    const existingRule = state.sortStack.find((rule) => rule.col === header);

                    if (event.shiftKey && existingRule) {
                        existingRule.dir = existingRule.dir === 'DESC' ? 'ASC' : 'DESC';
                    } else if (event.shiftKey) {
                        state.sortStack.push({ col: header, dir: 'DESC' });
                    } else {
                        state.sortStack = [{
                            col: header,
                            dir: existingRule ? (existingRule.dir === 'DESC' ? 'ASC' : 'DESC') : 'DESC'
                        }];
                    }

                    state.data = sortEsmRows(state.data, state.sortStack, context);
                    renderEsmTableBody(state);
                    refreshEsmHeaderStates(state);
                });

                headerRow.appendChild(th);
            });

            const footerCell = contentElement.querySelector('.esm-footer-cell');
            if (footerCell) {
                footerCell.colSpan = Math.max(1, headers.length);
            }

            state.data = sortEsmRows(state.data, state.sortStack, context);
            renderEsmTableBody(state);
            refreshEsmHeaderStates(state);

            const csvLink = contentElement.querySelector('.esm-csv-link');
            csvLink.addEventListener('click', (event) => {
                event.preventDefault();
                const csvFileName = buildEsmCsvFileName(programmerId);
                downloadEsmCsv(reportRows, state.sortStack[0], context, csvFileName);
            });

            const lastModifiedLabel = contentElement.querySelector('.esm-last-modified');
            if (lastModified) {
                const sourceTz = getLastModifiedSourceTimezone(lastModified);
                lastModifiedLabel.textContent = `Last-Modified: ${formatLastModifiedForDisplay(lastModified)}`;
                lastModifiedLabel.title = sourceTz
                    ? `Server time: ${sourceTz} (converted to your timezone)`
                    : 'Converted to your timezone';
            } else {
                lastModifiedLabel.textContent = 'Last-Modified: (real-time)';
            }
        }

        function buildEsmUrl() {
            const now = new Date();
            const start = new Date(now.getTime() - (60 * 60 * 1000));

            const params = new URLSearchParams();
            params.set('start', isoTimestamp(start));
            params.set('end', isoTimestamp(now));
            params.set('format', 'json');
            params.set('limit', String(ESM_INLINE_RESULT_LIMIT));

            const selectedRequestor = document.getElementById('contentProviderSelect')?.value?.trim();
            if (selectedRequestor) {
                params.append('requestor-id', selectedRequestor);
            }

            const selectedMvpd = document.getElementById('mvpdSelect')?.value?.trim();
            if (selectedMvpd) {
                params.append('mvpd', selectedMvpd);
            }

            return `${ADOBE_MGMT_BASE}/esm/v3/media-company/year/month/day/hour/minute?${params.toString()}`;
        }

        async function loadEsmService(programmerId, appInfo, contentElement, refreshButton, requestToken) {
            if (!contentElement) {
                return;
            }
            if (refreshButton) {
                refreshButton.disabled = true;
            }
            contentElement.innerHTML = '<div class="loading">Loading ESM data...</div>';

            try {
                const url = buildEsmUrl();
                const response = await fetchWithPremiumAuth(programmerId, appInfo, url, { method: 'GET' });
                const lastModified = response.headers.get('Last-Modified');
                const bodyText = await response.text();

                if (requestToken !== activeMetadataRequestToken) {
                    return;
                }

                if (!response.ok) {
                    contentElement.innerHTML = `<div class="service-error">HTTP ${response.status} ${escapeHtml(response.statusText)}
${escapeHtml(bodyText || '')}</div>`;
                    return;
                }

                let jsonData = null;
                try {
                    jsonData = bodyText ? JSON.parse(bodyText) : null;
                } catch (error) {
                    jsonData = null;
                }

                const reportRows = Array.isArray(jsonData?.report) ? jsonData.report : [];
                renderEsmReportTable(contentElement, reportRows, lastModified, programmerId);
            } catch (error) {
                if (requestToken !== activeMetadataRequestToken) {
                    return;
                }
                contentElement.innerHTML = `<div class="service-error">${escapeHtml(error.message)}</div>`;
            } finally {
                if (refreshButton) {
                    refreshButton.disabled = false;
                }
            }
        }

        function renderRestV2ComingSoon(contentElement, appInfo) {
            contentElement.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-key">REST V2</div>
                    <div class="metadata-value">Coming Soon. Using ${escapeHtml(appInfo.appName)} with REST V2 API.</div>
                </div>
            `;
        }

        function renderPremiumServiceSections(programmerId, premiumApps, requestToken) {
            const premiumContainer = document.getElementById('premiumServicesContainer');
            if (!premiumContainer) {
                return;
            }
            premiumContainer.innerHTML = '';

            const availableKeys = PREMIUM_SERVICE_ORDER.filter((serviceKey) => Boolean(premiumApps[serviceKey]));
            if (availableKeys.length === 0) {
                return;
            }

            availableKeys.forEach((serviceKey) => {
                const appInfo = premiumApps[serviceKey];
                const section = createPremiumServiceSection(serviceKey, appInfo);
                premiumContainer.appendChild(section.section);

                if (serviceKey === 'degradation') {
                    const refresh = () => loadDegradationService(programmerId, appInfo, section.contentElement, section.refreshButton, requestToken);
                    section.refreshButton.addEventListener('click', refresh);
                    refresh();
                    return;
                }

                if (serviceKey === 'esm') {
                    const refresh = () => loadEsmService(programmerId, appInfo, section.contentElement, section.refreshButton, requestToken);
                    section.refreshButton.addEventListener('click', refresh);
                    refresh();
                    return;
                }

                if (serviceKey === 'restV2') {
                    section.refreshButton.style.display = 'none';
                    renderRestV2ComingSoon(section.contentElement, appInfo);
                }
            });
        }

        // Check if a value is empty (null, undefined, empty object, empty array, empty string)
        function isEmptyValue(value) {
            if (value === null || value === undefined) {
                return true;
            }
            if (typeof value === 'string' && value.trim() === '') {
                return true;
            }
            if (Array.isArray(value) && value.length === 0) {
                return true;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return true;
            }
            return false;
        }

        // Display metadata for selected programmer
        async function displayMetadata(programmerIndex) {
            const requestToken = ++activeMetadataRequestToken;
            const container = document.getElementById('metadataContainer');
            const metadataHeader = document.getElementById('metadataHeader');
            const headerSpan = metadataHeader.querySelector('span');
            
            // Populate content providers dropdown
            populateContentProviders(programmerIndex);
            
            if (programmerIndex === '' || !programmersData) {
                // Reset header to default
                headerSpan.textContent = 'Metadata';
                clearPremiumServicesContainer();
                container.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <p>Select a programmer from the dropdown above to view their metadata</p>
                    </div>
                `;
                return;
            }

            const entity = programmersData.entities[programmerIndex];
            const entityData = entity.entityData || {};
            const programmerId = entityData.id;
            const programmerName = entityData.displayName || programmerId || 'Unknown';
            
            // Update header to show programmer name
            headerSpan.textContent = `${programmerName} info.`;
            
            // Show loading state
            container.innerHTML = '<div style="text-align: center; padding: var(--spectrum-global-dimension-size-500); color: var(--spectrum-global-color-blue-600);"><div>Loading metadata...</div></div>';
            
            // Fetch applications for this programmer
            let applicationsData = null;
            if (programmerId && isAuthenticated) {
                applicationsData = await fetchApplicationsForProgrammer(programmerId);
            }

            if (requestToken !== activeMetadataRequestToken) {
                return;
            }
            
            let html = '';
            // Metadata keys to hide from the info box (Content Providers appear in the dropdown instead)
            const METADATA_HIDDEN_KEYS = new Set([
                'serviceProviders', 'id', 'featureFlags', 'displayName',
                'customSchemes', 'contentProviders', 'certificates'
            ]);
            // Filter out keys with empty values and hidden keys
            const keys = Object.keys(entityData)
                .filter(key => !isEmptyValue(entityData[key]) && !METADATA_HIDDEN_KEYS.has(key))
                .sort();

            keys.forEach(key => {
                const value = entityData[key];
                let formattedValue;
                
                // Special handling for applications array
                if (key === 'applications' && Array.isArray(value) && applicationsData) {
                    formattedValue = formatApplicationsWithScopes(value, applicationsData, programmerId);
                } else {
                    formattedValue = formatValue(value, 0, key);
                }
                
                html += `
                    <div class="metadata-item">
                        <div class="metadata-key">${key}</div>
                        <div class="metadata-value">${formattedValue}</div>
                    </div>
                `;
            });

            container.innerHTML = html || '<div class="metadata-item"><div class="metadata-key">Info</div><div class="metadata-value"><span class="null-value">No non-empty metadata fields were found for this programmer.</span></div></div>';

            if (requestToken !== activeMetadataRequestToken) {
                return;
            }

            const premiumApps = findPremiumServiceApplications(entityData.applications || [], applicationsData || {});
            await enrichPremiumAppsWithSoftwareStatements(premiumApps);
            if (requestToken !== activeMetadataRequestToken) {
                return;
            }
            renderPremiumServiceSections(programmerId, premiumApps, requestToken);
        }

        // Event listeners
        document.getElementById('authBtn').addEventListener('click', function() {
            if (isAuthenticated) {
                // Refresh session and reload data
                checkAuthentication();
            } else {
                initiateAdobeLogin();
            }
        });

        document.getElementById('programmerSelect').addEventListener('change', async function(e) {
            await displayMetadata(e.target.value);
        });

        // Handle content provider selection change
        document.getElementById('contentProviderSelect').addEventListener('change', async function(e) {
            const requestorId = e.target.value;
            await populateMvpdsFromConfig(requestorId);
        });

        // Toggle metadata container collapse/expand
        document.getElementById('metadataHeader').addEventListener('click', function() {
            const container = document.getElementById('metadataContainer');
            const header = document.getElementById('metadataHeader');
            
            if (container.classList.contains('collapsed')) {
                container.classList.remove('collapsed');
                header.classList.remove('collapsed');
            } else {
                container.classList.add('collapsed');
                header.classList.add('collapsed');
            }
        });

        // Handle application link clicks with authentication check
        async function handleApplicationLinkClick(event, url) {
            // Let the default link behavior happen, but we can add auth check if needed
            // The browser will handle the redirect to login if not authenticated
            // For now, just let it proceed - the server will redirect to login if needed
        }

        // Make function available globally for onclick handlers
        window.handleApplicationLinkClick = handleApplicationLinkClick;

        // Check authentication on page load
        checkAuthentication();
    </script>
</body>
</html>
